<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jayara - Secure Chat</title>
    <meta name="theme-color" content="#4f46e5">
    <link rel="icon" type="image/png" sizes="192x192" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiByeD0iMjQiIGZpbGw9IiM0ZjQ2ZTUiLz4KPHN2ZyB4PSI0OCIgeT0iNDgiIHdpZHRoPSI5NiIgaGVpZ2h0PSI5NiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0yMCA0SDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWNmMwLTEuMS0uOS0yLTItMnpNMjAgMTZINHYtNmgxNnY2eiIvPgo8L3N2Zz4KPC9zdmc+">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #333;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .header {
            background: #4f46e5;
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .join-screen {
            padding: 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1rem;
        }

        .chat-screen {
            display: none;
            flex-direction: column;
            height: 100vh;
        }

        .chat-header {
            background: #f8fafc;
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-info {
            font-size: 0.9rem;
            color: #64748b;
        }

        .mode-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .vanish-mode {
            background: #fef3c7;
            color: #d97706;
        }

        .storage-mode {
            background: #dbeafe;
            color: #2563eb;
        }

        .call-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .call-btn {
            padding: 0.5rem;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .call-btn.voice {
            background: #10b981;
            color: white;
        }

        .call-btn.video {
            background: #3b82f6;
            color: white;
        }

        .call-btn:hover {
            transform: scale(1.1);
        }

        .messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .message {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            word-wrap: break-word;
            animation: slideIn 0.3s ease-out;
        }

        .message.sent {
            align-self: flex-end;
            background: #4f46e5;
            color: white;
            border-bottom-right-radius: 0.25rem;
        }

        .message.received {
            align-self: flex-start;
            background: #f1f5f9;
            color: #334155;
            border-bottom-left-radius: 0.25rem;
        }

        .message-meta {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        .input-area {
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            background: white;
            display: flex;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #374151;
        }

        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        #messageInput {
            flex: 1;
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 0.75rem 1rem;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #4338ca;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-danger {
            background: #ef4444;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        #sendButton {
            border-radius: 1rem;
            padding: 0.75rem 1rem;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .controls button {
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
        }

        .debug {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #64748b;
        }

        .debug-entry {
            margin-bottom: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        /* Call Overlay Styles */
        .call-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .call-container {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .video-container {
            position: relative;
            margin: 1rem 0;
        }

        .remote-video, .local-video, .remote-audio {
            width: 100%;
            max-width: 300px;
            border-radius: 0.5rem;
        }

        .local-video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 75px;
            border: 2px solid white;
        }

        .call-status {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #374151;
        }

        .call-participant {
            font-size: 1rem;
            color: #64748b;
            margin-bottom: 1.5rem;
        }

        .call-controls-overlay {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .call-control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .call-control-btn.mute {
            background: #10b981;
            color: white;
        }

        .call-control-btn.mute.active {
            background: #ef4444;
        }

        .call-control-btn.video {
            background: #3b82f6;
            color: white;
        }

        .call-control-btn.video.active {
            background: #ef4444;
        }

        .call-control-btn.end {
            background: #ef4444;
            color: white;
        }

        .call-control-btn:hover {
            transform: scale(1.1);
        }

        /* Incoming Call UI */
        .incoming-call {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            display: none;
        }

        .incoming-call-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .accept-btn {
            background: #10b981;
        }

        .decline-btn {
            background: #ef4444;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 640px) {
            .container {
                min-height: 100vh;
            }

            .join-screen {
                padding: 1rem;
            }

            .message {
                max-width: 90%;
            }

            .controls {
                justify-content: center;
            }

            .controls button {
                flex: 1;
                min-width: 120px;
            }

            .call-controls-overlay {
                gap: 0.5rem;
            }

            .call-control-btn {
                width: 45px;
                height: 45px;
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🔐 Jayara</h1>
            <p>Secure End-to-End Encrypted Chat</p>
        </div>

        <!-- Join Screen -->
        <div class="join-screen" id="joinScreen">
            <div class="form-group">
                <label for="username">Username</label>
                <input type="text" id="username" placeholder="Enter your username" maxlength="20">
            </div>

            <div class="form-group">
                <label for="roomCode">Room Code</label>
                <input type="text" id="roomCode" placeholder="Enter room code" maxlength="20">
            </div>

            <div class="form-group">
                <label for="passphrase">Passphrase (for encryption)</label>
                <input type="password" id="passphrase" placeholder="Enter passphrase">
            </div>

            <div class="form-group">
                <label for="chatMode">Chat Mode</label>
                <select id="chatMode">
                    <option value="vanish">Vanish Mode (24h auto-delete)</option>
                    <option value="storage">Storage Mode (7 days retention)</option>
                </select>
            </div>

            <button id="joinButton">Join Room</button>

            <div class="controls">
                <button id="cleanupButton" class="btn-secondary">🧹 Cleanup Room</button>
            </div>

            <div class="debug" id="debugLog">
                <div class="debug-entry">Ready to join...</div>
            </div>
        </div>

        <!-- Chat Screen -->
        <div class="chat-screen" id="chatScreen">
            <div class="chat-header">
                <div class="room-info">
                    <div id="roomDisplay"></div>
                    <div id="userDisplay"></div>
                </div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div class="call-controls">
                        <button class="call-btn voice" onclick="startVoiceCall()" title="Voice Call">📞</button>
                        <button class="call-btn video" onclick="startVideoCall()" title="Video Call">📹</button>
                    </div>
                    <div id="modeDisplay"></div>
                </div>
            </div>

            <div class="messages" id="messages"></div>

            <div class="input-area">
                <input type="text" id="messageInput" placeholder="Type a message..." maxlength="500">
                <button id="sendButton">Send</button>
            </div>

            <div class="controls">
                <button id="leaveButton" class="btn-danger">Leave Room</button>
                <button id="clearLocalButton" class="btn-secondary">Clear Local</button>
                <button id="cleanupRoomButton" class="btn-secondary">🧹 Cleanup</button>
            </div>

            <div class="debug" id="chatDebugLog"></div>
        </div>
    </div>

    <!-- Call Overlay -->
    <div class="call-overlay" id="callOverlay">
        <div class="call-container">
            <div class="call-status" id="callStatus">Connecting...</div>
            <div class="call-participant" id="callParticipant">VOICE CALL</div>
            
            <div class="video-container">
                <video id="remoteVideo" class="remote-video" autoplay playsinline style="display: none;"></video>
                <video id="localVideo" class="local-video" autoplay muted playsinline style="display: none;"></video>
                <audio id="remoteAudio" autoplay></audio>
            </div>

            <div class="call-controls-overlay">
                <button class="call-control-btn mute" id="muteBtn" title="Mute">🎤</button>
                <button class="call-control-btn video" id="videoBtn" title="Camera" style="display: none;">📹</button>
                <button class="call-control-btn end" id="endCallBtn" title="End Call">📵</button>
            </div>
        </div>
    </div>

    <!-- Incoming Call UI -->
    <div class="incoming-call" id="incomingCallUI">
        <h3>Incoming Call</h3>
        <p id="callerName">Unknown</p>
        <p id="incomingCallType">Voice Call</p>
        <div class="incoming-call-buttons">
            <button class="accept-btn" id="acceptCallBtn">Accept</button>
            <button class="decline-btn" id="declineCallBtn">Decline</button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-database-compat.min.js"></script>
    
    <!-- CryptoJS for encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "your-api-key",
            authDomain: "your-project.firebaseapp.com",
            databaseURL: "https://your-project-default-rtdb.firebaseio.com/",
            projectId: "your-project-id",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "your-app-id"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // App state
        let currentUser = '';
        let currentRoom = '';
        let currentPassphrase = '';
        let currentMode = 'vanish';
        let messagesRef = null;
        let callRef = null;
        let isJoined = false;

        // WebRTC state
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let callState = 'idle'; // idle, calling, incoming, connected
        let currentCallType = null; // voice or video
        let isWebRTCSupported = false;

        // DOM elements
        const joinScreen = document.getElementById('joinScreen');
        const chatScreen = document.getElementById('chatScreen');
        const usernameInput = document.getElementById('username');
        const roomCodeInput = document.getElementById('roomCode');
        const passphraseInput = document.getElementById('passphrase');
        const chatModeSelect = document.getElementById('chatMode');
        const messageInput = document.getElementById('messageInput');
        const messagesDiv = document.getElementById('messages');
        const debugLog = document.getElementById('debugLog');
        const chatDebugLog = document.getElementById('chatDebugLog');
        const roomDisplay = document.getElementById('roomDisplay');
        const userDisplay = document.getElementById('userDisplay');
        const modeDisplay = document.getElementById('modeDisplay');

        // WebRTC Configuration
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Initialize WebRTC support check
        async function initializeWebRTC() {
            try {
                isWebRTCSupported = !!(navigator.mediaDevices && 
                    navigator.mediaDevices.getUserMedia && 
                    window.RTCPeerConnection);
                    
                log(`WebRTC Support: ${isWebRTCSupported ? '✅' : '❌'}`);
                return isWebRTCSupported;
            } catch (error) {
                log(`WebRTC initialization error: ${error.message}`);
                return false;
            }
        }

        // Check browser compatibility
        function checkBrowserCompatibility() {
            const issues = [];
            let isCompatible = true;

            if (!window.firebase) {
                issues.push('Firebase not supported');
                isCompatible = false;
            }

            if (!window.CryptoJS) {
                issues.push('CryptoJS not supported');
                isCompatible = false;
            }

            if (!navigator.mediaDevices) {
                issues.push('MediaDevices API not supported');
            }

            return { isCompatible, issues };
        }

        // Utility functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            
            if (isJoined) {
                chatDebugLog.appendChild(entry);
                chatDebugLog.scrollTop = chatDebugLog.scrollHeight;
            } else {
                debugLog.appendChild(entry);
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }

        function encrypt(text, passphrase) {
            return CryptoJS.AES.encrypt(text, passphrase).toString();
        }

        function decrypt(ciphertext, passphrase) {
            try {
                const bytes = CryptoJS.AES.decrypt(ciphertext, passphrase);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null;
            }
        }

        function generateId() {
            return Date.now().toString() + Math.random().toString(36).substr(2, 9);
        }

        // Load saved data
        function loadSavedData() {
            const savedUser = localStorage.getItem('jayara_username');
            const savedRoom = localStorage.getItem('jayara_room');
            
            if (savedUser) usernameInput.value = savedUser;
            if (savedRoom) roomCodeInput.value = savedRoom;
            
            log('Loaded saved data');
        }

        // Save user data
        function saveUserData() {
            localStorage.setItem('jayara_username', currentUser);
            localStorage.setItem('jayara_room', currentRoom);
        }

        // Message handling
        function addMessage(username, text, timestamp, isOwn = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'sent' : 'received'}`;
            
            const messageText = document.createElement('div');
            messageText.textContent = text;
            
            const messageMeta = document.createElement('div');
            messageMeta.className = 'message-meta';
            messageMeta.textContent = `${username} • ${new Date(timestamp).toLocaleTimeString()}`;
            
            messageDiv.appendChild(messageText);
            messageDiv.appendChild(messageMeta);
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Send message
        function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || !currentPassphrase) return;

            const messageId = generateId();
            const timestamp = Date.now();
            const encryptedText = encrypt(text, currentPassphrase);
            
            const messageData = {
                id: messageId,
                username: currentUser,
                text: encryptedText,
                timestamp: timestamp,
                mode: currentMode
            };

            messagesRef.child(messageId).set(messageData)
                .then(() => {
                    messageInput.value = '';
                    log(`Message sent: ${text.substring(0, 20)}...`);
                })
                .catch(error => {
                    log(`Error sending message: ${error.message}`);
                });
        }

        // WebRTC Functions
        async function startVoiceCall() {
            if (!isWebRTCSupported) {
                alert('Voice calls are not supported in this browser');
                return;
            }
            
            try {
                log('Starting voice call...');
                currentCallType = 'voice';
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                await initiateCall('voice');
            } catch (error) {
                log(`Voice call error: ${error.message}`);
                alert('Could not access microphone');
            }
        }

        async function startVideoCall() {
            if (!isWebRTCSupported) {
                alert('Video calls are not supported in this browser');
                return;
            }
            
            try {
                log('Starting video call...');
                currentCallType = 'video';
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: true 
                });
                await initiateCall('video');
            } catch (error) {
                log(`Video call error: ${error.message}`);
                alert('Could not access camera/microphone');
            }
        }

        async function initiateCall(callType) {
            callState = 'calling';
            
            // Create peer connection
            peerConnection = new RTCPeerConnection(rtcConfiguration);
            
            // Add local stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                if (callType === 'video') {
                    document.getElementById('remoteVideo').srcObject = remoteStream;
                } else {
                    document.getElementById('remoteAudio').srcObject = remoteStream;
                }
                updateCallUI();
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    callRef.child('candidates').push({
                        candidate: event.candidate,
                        from: currentUser
                    });
                }
            };

            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // Send call offer through Firebase
            callRef = database.ref(`rooms/${currentRoom}/call`);
            await callRef.set({
                offer: offer,
                caller: currentUser,
                callType: callType,
                timestamp: Date.now()
            });

            showCallingUI(callType, 'Other User');
            
            // Listen for answer
            callRef.child('answer').on('value', async (snapshot) => {
                const answer = snapshot.val();
                if (answer && callState === 'calling') {
                    await peerConnection.setRemoteDescription(answer);
                    callState = 'connected';
                    showCallUI(callType, 'Other User');
                }
            });

            // Listen for ICE candidates
            callRef.child('candidates').on('child_added', async (snapshot) => {
                const candidate = snapshot.val();
                if (candidate && candidate.from !== currentUser) {
                    await peerConnection.addIceCandidate(candidate.candidate);
                }
            });
        }

        async function answerCall(callOffer) {
            try {
                log('Answering call...');
                callState = 'connected';
                currentCallType = callOffer.callType;

                // Get user media
                const constraints = callOffer.callType === 'video' 
                    ? { audio: true, video: true }
                    : { audio: true };
                    
                localStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Create peer connection
                peerConnection = new RTCPeerConnection(rtcConfiguration);
                
                // Add local stream
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle remote stream
                peerConnection.ontrack = (event) => {
                    remoteStream = event.streams[0];
                    if (callOffer.callType === 'video') {
                        document.getElementById('remoteVideo').srcObject = remoteStream;
                    } else {
                        document.getElementById('remoteAudio').srcObject = remoteStream;
                    }
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        callRef.child('candidates').push({
                            candidate: event.candidate,
                            from: currentUser
                        });
                    }
                };

                // Set remote description and create answer
                await peerConnection.setRemoteDescription(callOffer.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Send answer
                await callRef.child('answer').set(answer);

                showCallUI(callOffer.callType, callOffer.caller);

            } catch (error) {
                log(`Answer call error: ${error.message}`);
                endCall();
            }
        }

        function endCall() {
            log('Ending call...');
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Clear call reference
            if (callRef) {
                callRef.off();
                callRef.remove();
                callRef = null;
            }

            // Reset call state
            callState = 'idle';
            currentCallType = null;
            remoteStream = null;

            // Hide call UI
            hideCallUI();
        }

        // Call UI Functions
        function showCallingUI(callType, targetUser) {
            document.getElementById('callOverlay').style.display = 'flex';
            document.getElementById('callStatus').textContent = `Calling ${targetUser}...`;
            document.getElementById('callParticipant').textContent = `${callType.toUpperCase()} CALL`;
            
            if (callType === 'video') {
                document.getElementById('localVideo').style.display = 'block';
                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('videoBtn').style.display = 'block';
            } else {
                document.getElementById('localVideo').style.display = 'none';
                document.getElementById('videoBtn').style.display = 'none';
            }
        }

        function showCallUI(callType, participant) {
            document.getElementById('callOverlay').style.display = 'flex';
            document.getElementById('callStatus').textContent = 'Connected';
            document.getElementById('callParticipant').textContent = `${callType.toUpperCase()} CALL with ${participant}`;
            
            if (callType === 'video') {
                document.getElementById('localVideo').style.display = 'block';
                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('remoteVideo').style.display = 'block';
                document.getElementById('videoBtn').style.display = 'block';
            } else {
                document.getElementById('localVideo').style.display = 'none';
                document.getElementById('remoteVideo').style.display = 'none';
                document.getElementById('videoBtn').style.display = 'none';
            }
        }

        function showIncomingCallUI(callOffer) {
            document.getElementById('incomingCallUI').style.display = 'block';
            document.getElementById('callerName').textContent = callOffer.caller;
            document.getElementById('incomingCallType').textContent = `Incoming ${callOffer.callType} call`;
            document.getElementById('incomingCallUI').dataset.callOffer = JSON.stringify(callOffer);
            
            callState = 'incoming';
            playRingtone();
        }

        function hideIncomingCallUI() {
            document.getElementById('incomingCallUI').style.display = 'none';
            callState = 'idle';
        }

        function hideCallUI() {
            document.getElementById('callOverlay').style.display = 'none';
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
            document.getElementById('remoteAudio').srcObject = null;
        }

        function updateCallUI() {
            document.getElementById('callStatus').textContent = 'Connected';
        }

        // Call control functions
        function toggleMute() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                const muteBtn = document.getElementById('muteBtn');
                
                audioTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                
                if (audioTracks[0] && !audioTracks[0].enabled) {
                    muteBtn.textContent = '🔇';
                    muteBtn.classList.add('active');
                } else {
                    muteBtn.textContent = '🎤';
                    muteBtn.classList.remove('active');
                }
            }
        }

        function toggleVideo() {
            if (localStream && currentCallType === 'video') {
                const videoTracks = localStream.getVideoTracks();
                const videoBtn = document.getElementById('videoBtn');
                
                videoTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                
                if (videoTracks[0] && !videoTracks[0].enabled) {
                    videoBtn.textContent = '📷';
                    videoBtn.classList.add('active');
                    document.getElementById('localVideo').style.display = 'none';
                } else {
                    videoBtn.textContent = '📹';
                    videoBtn.classList.remove('active');
                    document.getElementById('localVideo').style.display = 'block';
                }
            }
        }

        // Play ringtone for incoming calls
        function playRingtone() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
                
                // Repeat ringtone every 2 seconds
                const ringtoneInterval = setInterval(() => {
                    if (callState !== 'incoming') {
                        clearInterval(ringtoneInterval);
                        return;
                    }
                    
                    const newOscillator = audioContext.createOscillator();
                    const newGainNode = audioContext.createGain();
                    
                    newOscillator.connect(newGainNode);
                    newGainNode.connect(audioContext.destination);
                    
                    newOscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    newGainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    
                    newOscillator.start();
                    newOscillator.stop(audioContext.currentTime + 0.5);
                }, 2000);
                
            } catch (error) {
                log('Could not play ringtone: ' + error.message);
            }
        }

        // Setup call control event listeners
        function setupCallControls() {
            document.getElementById('endCallBtn').addEventListener('click', endCall);
            document.getElementById('muteBtn').addEventListener('click', toggleMute);
            document.getElementById('videoBtn').addEventListener('click', toggleVideo);
            
            document.getElementById('acceptCallBtn').addEventListener('click', () => {
                const callOffer = JSON.parse(document.getElementById('incomingCallUI').dataset.callOffer || '{}');
                hideIncomingCallUI();
                answerCall(callOffer);
            });
            
            document.getElementById('declineCallBtn').addEventListener('click', () => {
                hideIncomingCallUI();
                if (callRef) {
                    callRef.remove();
                }
            });
        }

        // Global functions for call buttons (called from onclick)
        window.startVoiceCall = startVoiceCall;
        window.startVideoCall = startVideoCall;

        // Cleanup old messages in current room only
        async function cleanupRoom() {
            if (!currentRoom) {
                alert('No room joined. Please join a room first.');
                return;
            }
            
            const confirmCleanup = confirm(
                '🧹 ROOM CLEANUP\n\n' +
                `This will delete old messages from room "${currentRoom}":\n` +
                '• Vanish mode messages older than 24 hours\n' +
                '• Storage mode messages older than 7 days\n\n' +
                'Continue?'
            );
            
            if (!confirmCleanup) {
                log('Room cleanup cancelled by user');
                return;
            }
            
            log(`🧹 Starting cleanup for room: ${currentRoom}...`);
            
            try {
                const snapshot = await messagesRef.once('value');
                const messages = snapshot.val() || {};
                const now = Date.now();
                const deletions = [];

                Object.keys(messages).forEach(key => {
                    const message = messages[key];
                    if (!message.timestamp) return; // Skip invalid messages
                    
                    const age = now - message.timestamp;
                    
                    // Delete vanish mode messages older than 24h
                    if (message.mode === 'vanish' && age > 24 * 60 * 60 * 1000) {
                        deletions.push(messagesRef.child(key).remove());
                    }
                    // Delete storage mode messages older than 7 days
                    else if (message.mode === 'storage' && age > 7 * 24 * 60 * 60 * 1000) {
                        deletions.push(messagesRef.child(key).remove());
                    }
                });

                if (deletions.length > 0) {
                    await Promise.all(deletions);
                    log(`✅ Room cleanup complete: ${deletions.length} messages removed from "${currentRoom}"`);
                    
                    alert(
                        `🧹 Room Cleanup Complete!\n\n` +
                        `Room: ${currentRoom}\n` +
                        `Messages deleted: ${deletions.length}`
                    );
                } else {
                    log(`✅ Room cleanup complete: No old messages found in "${currentRoom}"`);
                    alert(
                        `🧹 Room Cleanup Complete!\n\n` +
                        `Room: ${currentRoom}\n` +
                        `No old messages found to delete.`
                    );
                }
                
            } catch (error) {
                log(`❌ Room cleanup error: ${error.message}`);
                alert(`Room cleanup failed: ${error.message}`);
            }
        }

        // Join room
        async function joinRoom() {
            const username = usernameInput.value.trim();
            const roomCode = roomCodeInput.value.trim();
            const passphrase = passphraseInput.value.trim();
            const mode = chatModeSelect.value;

            if (!username || !roomCode || !passphrase) {
                log('Please fill all fields');
                return;
            }

            currentUser = username;
            currentRoom = roomCode;
            currentPassphrase = passphrase;
            currentMode = mode;
            
            log(`Joining room ${roomCode} as ${username} in ${mode} mode...`);
            
            // Setup Firebase references
            messagesRef = database.ref(`rooms/${roomCode}/messages`);

            // Listen for messages
            messagesRef.on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (!message) return;

                const decryptedText = decrypt(message.text, currentPassphrase);
                if (decryptedText) {
                    const isOwn = message.username === currentUser;
                    addMessage(message.username, decryptedText, message.timestamp, isOwn);
                } else {
                    log('Failed to decrypt message (wrong passphrase?)');
                }
            });

            // Listen for incoming calls
            const callsRef = database.ref(`rooms/${roomCode}/call`);
            callsRef.on('value', (snapshot) => {
                const callData = snapshot.val();
                if (callData && callData.caller !== currentUser && callState === 'idle') {
                    showIncomingCallUI(callData);
                    callRef = callsRef;
                }
            });

            // Update UI
            roomDisplay.textContent = `Room: ${roomCode}`;
            userDisplay.textContent = `User: ${username}`;
            modeDisplay.innerHTML = `<div class="mode-badge ${mode}-mode">${mode.toUpperCase()}</div>`;
            
            // Save data and switch screens
            saveUserData();
            isJoined = true;
            joinScreen.style.display = 'none';
            chatScreen.style.display = 'flex';
            
            messageInput.focus();
            log('Successfully joined room');
            
            // Auto-cleanup on join
            setTimeout(cleanupRoom, 1000);
        }

        // Leave room
        function leaveRoom() {
            if (messagesRef) {
                messagesRef.off();
                messagesRef = null;
            }
            
            if (callRef) {
                callRef.off();
                callRef = null;
            }
            
            // End any active call
            if (callState !== 'idle') {
                endCall();
            }
            
            currentUser = '';
            currentRoom = '';
            currentPassphrase = '';
            isJoined = false;
            
            messagesDiv.innerHTML = '';
            chatDebugLog.innerHTML = '';
            
            joinScreen.style.display = 'flex';
            chatScreen.style.display = 'none';
            
            log('Left room');
        }

        // Clear local messages
        function clearLocal() {
            messagesDiv.innerHTML = '';
            log('Local messages cleared');
        }

        // Initialize app with WebRTC support
        async function initializeApp() {
            try {
                log('🚀 Jayara Chat App Starting...');
                
                // Check basic browser compatibility
                const compatibility = checkBrowserCompatibility();
                if (!compatibility.isCompatible) {
                    log(`❌ Compatibility issues: ${compatibility.issues.join(', ')}`);
                    alert('Your browser is not compatible with this app. Please use a modern browser.');
                    return;
                }
                
                // Load saved data
                loadSavedData();
                
                // Initialize WebRTC
                const webrtcSupported = await initializeWebRTC();
                
                // Show detailed environment info
                log(`🌐 Origin: ${window.location.origin}`);
                log(`📱 User Agent: ${navigator.userAgent.substring(0, 80)}...`);
                log(`📡 WebRTC: ${webrtcSupported ? 'Supported' : 'Not supported'}`);
                log(`🔥 Firebase: ${typeof firebase !== 'undefined' ? 'Loaded' : 'NOT LOADED'}`);
                log(`🔐 CryptoJS: ${typeof CryptoJS !== 'undefined' ? 'Loaded' : 'NOT LOADED'}`);
                
                // Test critical dependencies
                if (typeof firebase === 'undefined') {
                    log('❌ CRITICAL: Firebase not loaded');
                    alert('Firebase failed to load. Please check your internet connection and try again.');
                    return;
                }
                
                if (typeof CryptoJS === 'undefined') {
                    log('❌ CRITICAL: CryptoJS not loaded');
                    alert('Encryption library failed to load. Please check your internet connection and try again.');
                    return;
                }
                
                // Test Firebase initialization
                try {
                    const testDB = firebase.database();
                    log('✅ Firebase database initialized');
                } catch (firebaseError) {
                    log(`❌ Firebase initialization error: ${firebaseError.message}`);
                    alert('Firebase initialization failed. Please refresh the page.');
                    return;
                }
                
                // Setup call control event listeners
                setupCallControls();
                
                // Show success message
                log('✅ Jayara initialized successfully');
                if (webrtcSupported) {
                    log('📞 Voice & Video calls are available!');
                } else {
                    log('📞 Voice & Video calls not supported in this browser');
                }
                
            } catch (error) {
                log(`❌ Critical initialization error: ${error.message}`);
                alert(`App failed to initialize: ${error.message}\n\nPlease refresh the page.`);
            }
        }

        // Event listeners
        document.getElementById('joinButton').addEventListener('click', joinRoom);
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('leaveButton').addEventListener('click', leaveRoom);
        document.getElementById('clearLocalButton').addEventListener('click', clearLocal);
        document.getElementById('cleanupRoomButton').addEventListener('click', cleanupRoom);
        document.getElementById('globalCleanupButton').addEventListener('click', globalCleanup);

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Auto-cleanup interval (every 30 minutes) - silent cleanup
        setInterval(() => {
            if (isJoined) {
                autoCleanupRoom();
            }
        }, 30 * 60 * 1000);

        // Initialize app
        initializeApp();
    </script>
</body>
</html>
