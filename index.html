<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jayara - Secure Chat</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4f46e5">
    <link rel="icon" type="image/png" sizes="192x192" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiByeD0iMjQiIGZpbGw9IiM0ZjQ2ZTUiLz4KPHN2ZyB4PSI0OCIgeT0iNDgiIHdpZHRoPSI5NiIgaGVpZ2h0PSI5NiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0yMCA0SDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWNmMwLTEuMS0uOS0yLTItMnpNMjAgMTZINHYtNmgxNnY2eiIvPgo8L3N2Zz4KPC9zdmc+">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #333;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .header {
            background: #4f46e5;
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .join-screen {
            padding: 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1rem;
        }

        .chat-screen {
            display: none;
            flex-direction: column;
            height: 100vh;
        }

        .chat-header {
            background: #f8fafc;
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-info {
            font-size: 0.9rem;
            color: #64748b;
        }

        .mode-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .vanish-mode {
            background: #fef3c7;
            color: #d97706;
        }

        .storage-mode {
            background: #dbeafe;
            color: #2563eb;
        }

        .messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .message {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            word-wrap: break-word;
            animation: slideIn 0.3s ease-out;
            transition: opacity 0.3s ease;
            position: relative;
            overflow-wrap: break-word;
        }

        .message.sent {
            align-self: flex-end;
            background: #4f46e5;
            color: white;
            border-bottom-right-radius: 0.25rem;
        }

        .message.received {
            align-self: flex-start;
            background: #f1f5f9;
            color: #334155;
            border-bottom-left-radius: 0.25rem;
        }

        .message.unread {
            border-left: 4px solid #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { border-left-color: #10b981; }
            50% { border-left-color: #34d399; }
        }

        .message-text {
            margin-bottom: 0.25rem;
        }

        .message-meta {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            background: white;
            display: flex;
            gap: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #374151;
        }

        input, textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        #messageInput {
            flex: 1;
            border: 2px solid #e5e7eb;
            border-radius: 1rem;
            padding: 0.75rem 1rem;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #4338ca;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-danger {
            background: #ef4444;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        #sendButton {
            border-radius: 1rem;
            padding: 0.75rem 1rem;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .controls button {
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
        }

        .debug {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #64748b;
        }

        .debug-entry {
            margin-bottom: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        .status {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.info {
            background: #dbeafe;
            color: #1e40af;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 640px) {
            .container {
                min-height: 100vh;
            }

            .join-screen {
                padding: 1rem;
            }

            .message {
                max-width: 90%;
            }

            .controls {
                justify-content: center;
            }

            .controls button {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üîê Jayara</h1>
            <p>Secure End-to-End Encrypted Chat</p>
        </div>

        <!-- Join Screen -->
        <div class="join-screen" id="joinScreen">
            <div class="form-group">
                <label for="username">Username</label>
                <input type="text" id="username" placeholder="Enter your username" maxlength="20">
            </div>

            <div class="form-group">
                <label for="roomCode">Room Code</label>
                <input type="text" id="roomCode" placeholder="Enter room code" maxlength="20">
            </div>

            <div class="form-group">
                <label for="passphrase">Passphrase (for encryption)</label>
                <input type="password" id="passphrase" placeholder="Enter passphrase">
            </div>

            <div class="form-group">
                <label for="chatMode">Chat Mode</label>
                <select id="chatMode">
                    <option value="vanish">Vanish Mode (24h auto-delete)</option>
                    <option value="storage">Storage Mode (7 days retention)</option>
                </select>
            </div>

            <div class="controls">
                <button id="joinButton">Join Room</button>
                <button id="requestNotificationsButton" class="btn-secondary" style="display: none;">üîî Enable Notifications</button>
            </div>

            <div class="controls">
                <button id="cleanupButton" class="btn-secondary">üßπ Cleanup Room</button>
                <button id="globalCleanupButton" class="btn-danger">üö® Global Cleanup ALL</button>
            </div>

            <div class="debug" id="debugLog">
                <div class="debug-entry">Ready to join...</div>
            </div>
        </div>

        <!-- Chat Screen -->
        <div class="chat-screen" id="chatScreen">
            <div class="chat-header">
                <div class="room-info">
                    <div id="roomDisplay"></div>
                    <div id="userDisplay"></div>
                </div>
                <div id="modeDisplay"></div>
            </div>

            <div class="messages" id="messages"></div>

            <div class="input-area">
                <input type="text" id="messageInput" placeholder="Type a message..." maxlength="500">
                <button id="sendButton">Send</button>
            </div>

            <div class="controls">
                <button id="leaveButton" class="btn-danger">Leave Room</button>
                <button id="clearLocalButton" class="btn-secondary">Clear Local</button>
                <button id="cleanupRoomButton" class="btn-secondary">üßπ Cleanup</button>
                <button id="globalCleanupChatButton" class="btn-danger">üö® Global Cleanup</button>
            </div>

            <div class="debug" id="chatDebugLog"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-database-compat.min.js"></script>
    
    <!-- CryptoJS for encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB0G0JLoNejrshjLaKxFR264cY11rmhVJU",
            authDomain: "jayara-web.firebaseapp.com",
            databaseURL: "https://jayara-web-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "jayara-web",
            storageBucket: "jayara-web.firebasestorage.app",
            messagingSenderId: "342182893596",
            appId: "1:342182893596:web:664646e95a40e60d0da7d9"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // App state
        let currentUser = '';
        let currentRoom = '';
        let currentPassphrase = '';
        let currentMode = 'vanish';
        let messagesRef = null;
        let roomRef = null;
        let presenceRef = null;
        let isJoined = false;
        let userPresenceId = '';
        let notificationPermission = 'default';

        // DOM elements
        const joinScreen = document.getElementById('joinScreen');
        const chatScreen = document.getElementById('chatScreen');
        const usernameInput = document.getElementById('username');
        const roomCodeInput = document.getElementById('roomCode');
        const passphraseInput = document.getElementById('passphrase');
        const chatModeSelect = document.getElementById('chatMode');
        const messageInput = document.getElementById('messageInput');
        const messagesDiv = document.getElementById('messages');
        const debugLog = document.getElementById('debugLog');
        const chatDebugLog = document.getElementById('chatDebugLog');
        const roomDisplay = document.getElementById('roomDisplay');
        const userDisplay = document.getElementById('userDisplay');
        const modeDisplay = document.getElementById('modeDisplay');

        // Utility functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'debug-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            
            if (isJoined) {
                chatDebugLog.appendChild(entry);
                chatDebugLog.scrollTop = chatDebugLog.scrollHeight;
            } else {
                debugLog.appendChild(entry);
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }

        function encrypt(text, passphrase) {
            return CryptoJS.AES.encrypt(text, passphrase).toString();
        }

        function decrypt(ciphertext, passphrase) {
            try {
                const bytes = CryptoJS.AES.decrypt(ciphertext, passphrase);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null;
            }
        }

        function generateId() {
            return Date.now().toString() + Math.random().toString(36).substr(2, 9);
        }

        // Load saved data and restore session
        function loadSavedData() {
            const savedUser = localStorage.getItem('jayara_username');
            const savedRoom = localStorage.getItem('jayara_room');
            const savedMode = localStorage.getItem('jayara_mode');
            const savedSession = localStorage.getItem('jayara_active_session');
            
            if (savedUser) usernameInput.value = savedUser;
            if (savedRoom) roomCodeInput.value = savedRoom;
            if (savedMode) chatModeSelect.value = savedMode;
            
            // Auto-rejoin if in storage mode and had active session
            if (savedSession && savedMode === 'storage' && savedUser && savedRoom) {
                log('Found active storage mode session - ready to rejoin');
                showSessionRestorePrompt(savedUser, savedRoom);
            }
            
            log('Loaded saved data');
        }

        // Show session restore prompt
        function showSessionRestorePrompt(username, room) {
            const restoreDiv = document.createElement('div');
            restoreDiv.className = 'status info';
            restoreDiv.innerHTML = `
                <strong>Resume Session?</strong><br>
                Found active session for <strong>${username}</strong> in room <strong>${room}</strong><br>
                <button onclick="quickRejoin()" style="margin-top: 0.5rem; margin-right: 0.5rem;">Resume Chat</button>
                <button onclick="clearSession()" class="btn-secondary" style="margin-top: 0.5rem;">Start Fresh</button>
            `;
            joinScreen.insertBefore(restoreDiv, joinScreen.firstChild);
        }

        // Quick rejoin for storage mode
        window.quickRejoin = function() {
            const savedUser = localStorage.getItem('jayara_username');
            const savedRoom = localStorage.getItem('jayara_room');
            
            usernameInput.value = savedUser;
            roomCodeInput.value = savedRoom;
            chatModeSelect.value = 'storage';
            
            // Focus on passphrase input
            passphraseInput.focus();
            passphraseInput.placeholder = 'Enter your passphrase to resume...';
            
            document.querySelector('.status').remove();
        };

        // Clear session
        window.clearSession = function() {
            localStorage.removeItem('jayara_active_session');
            localStorage.removeItem('jayara_mode');
            document.querySelector('.status').remove();
        };

        // Save user data and session
        function saveUserData() {
            localStorage.setItem('jayara_username', currentUser);
            localStorage.setItem('jayara_room', currentRoom);
            localStorage.setItem('jayara_mode', currentMode);
            
            // Save active session only in storage mode
            if (currentMode === 'storage') {
                localStorage.setItem('jayara_active_session', 'true');
            } else {
                localStorage.removeItem('jayara_active_session');
            }
        }

        // Request notification permission
        async function requestNotificationPermission() {
            if ('Notification' in window && 'serviceWorker' in navigator) {
                notificationPermission = await Notification.requestPermission();
                if (notificationPermission === 'granted') {
                    log('üîî Notification permission granted');
                    await subscribeToNotifications();
                } else {
                    log('üîï Notification permission denied');
                }
            }
        }

        // Subscribe to push notifications with your VAPID key
        async function subscribeToNotifications() {
            try {
                const registration = await navigator.serviceWorker.ready;
                const subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: urlBase64ToUint8Array('BP2a0ozwY3d0DW3eEih0c_Ai0iaNngCyhDWIzzIM2umb5ZWrMwAXaDVw4yjbPSKYYuNDUAYg-U3nDGmumBMt7i0')
                });
                
                // Store subscription in Firebase for this user/room
                const subscriptionData = {
                    endpoint: subscription.endpoint,
                    keys: subscription.toJSON().keys,
                    userId: userPresenceId,
                    room: currentRoom,
                    username: currentUser,
                    timestamp: Date.now()
                };
                
                await database.ref(`notifications/${currentRoom}/${userPresenceId}`).set(subscriptionData);
                log('üì± Push notification subscription saved with VAPID key');
                
            } catch (error) {
                log(`Notification subscription error: ${error.message}`);
                log('üì± Falling back to local notifications only');
            }
        }

        // Helper function for VAPID key conversion
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // User presence management
        async function setupPresence() {
            userPresenceId = generateId();
            const presenceData = {
                username: currentUser,
                joinedAt: Date.now(),
                lastSeen: Date.now(),
                mode: currentMode,
                online: true
            };

            presenceRef = database.ref(`rooms/${currentRoom}/presence/${userPresenceId}`);
            
            // Set initial presence
            await presenceRef.set(presenceData);
            
            // Update last seen periodically
            const heartbeatInterval = setInterval(() => {
                if (isJoined) {
                    presenceRef.update({ lastSeen: Date.now(), online: true });
                } else {
                    clearInterval(heartbeatInterval);
                }
            }, 30000); // Every 30 seconds

            // Handle disconnect - crucial for cleanup
            presenceRef.onDisconnect().update({ online: false, leftAt: Date.now() });
            
            // Listen for presence changes
            const roomPresenceRef = database.ref(`rooms/${currentRoom}/presence`);
            roomPresenceRef.on('child_removed', async (snapshot) => {
                const leftUser = snapshot.val();
                log(`üëã ${leftUser.username} left the room`);
                
                // Check if room should be cleaned up
                await checkRoomCleanup();
            });

            log(`‚úÖ Presence setup for ${currentUser}`);
        }

        // Check if room needs cleanup (vanish mode or empty room)
        async function checkRoomCleanup() {
            try {
                const roomPresenceSnapshot = await database.ref(`rooms/${currentRoom}/presence`).once('value');
                const presenceData = roomPresenceSnapshot.val() || {};
                
                // Get online users
                const onlineUsers = Object.values(presenceData).filter(user => user.online);
                
                // If vanish mode and user leaves, delete their messages
                if (currentMode === 'vanish') {
                    // Clean up messages for this user session
                    await cleanupUserMessages(userPresenceId);
                }
                
                // If no users online, clean up room (especially for vanish mode)
                if (onlineUsers.length === 0) {
                    log('üßπ No active users - cleaning up room');
                    
                    if (currentMode === 'vanish') {
                        // Delete all messages in vanish mode
                        await database.ref(`rooms/${currentRoom}/messages`).remove();
                        await database.ref(`rooms/${currentRoom}/presence`).remove();
                        await database.ref(`notifications/${currentRoom}`).remove();
                        log('üóëÔ∏è Vanish mode: Room completely cleaned');
                    }
                }
                
            } catch (error) {
                log(`Cleanup check error: ${error.message}`);
            }
        }

        // Clean up messages for a specific user (vanish mode)
        async function cleanupUserMessages(userId) {
            if (currentMode !== 'vanish') return;
            
            try {
                const messagesSnapshot = await messagesRef.once('value');
                const messages = messagesSnapshot.val() || {};
                
                // Remove messages from this user session
                const deletions = [];
                Object.keys(messages).forEach(key => {
                    const message = messages[key];
                    if (message.userId === userId) {
                        deletions.push(messagesRef.child(key).remove());
                    }
                });
                
                await Promise.all(deletions);
                log(`üßπ Cleaned ${deletions.length} messages for departed user`);
                
            } catch (error) {
                log(`User message cleanup error: ${error.message}`);
            }
        }
        function addMessage(username, text, timestamp, isOwn = false, messageId) {
            // Check for duplicate messages
            if (document.getElementById(`msg-${messageId}`)) {
                return;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'sent' : 'received'}`;
            messageDiv.id = `msg-${messageId}`;
            
            const messageText = document.createElement('div');
            messageText.textContent = text;
            
            const messageMeta = document.createElement('div');
            messageMeta.className = 'message-meta';
            messageMeta.textContent = `${username} ‚Ä¢ ${new Date(timestamp).toLocaleTimeString()}`;
            
            messageDiv.appendChild(messageText);
            messageDiv.appendChild(messageMeta);
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Auto-scroll to bottom with smooth behavior
            setTimeout(() => {
                messagesDiv.scrollTo({
                    top: messagesDiv.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        }

        // Send message with user tracking
        function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || !currentPassphrase) return;

            // Disable send button to prevent double-sending
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            const messageId = generateId();
            const timestamp = Date.now();
            const encryptedText = encrypt(text, currentPassphrase);
            
            const messageData = {
                id: messageId,
                userId: userPresenceId, // Track which user sent this
                username: currentUser,
                text: encryptedText,
                timestamp: timestamp,
                mode: currentMode
            };

            messagesRef.child(messageId).set(messageData)
                .then(() => {
                    messageInput.value = '';
                    log(`Message sent: ${text.substring(0, 20)}${text.length > 20 ? '...' : ''}`);
                    
                    // Send notifications to other users
                    sendNotificationToOthers(text);
                })
                .catch(error => {
                    log(`Error sending message: ${error.message}`);
                })
                .finally(() => {
                    sendButton.disabled = false;
                });
        }

        // Send push notifications to other users in the room
        async function sendNotificationToOthers(messageText) {
            try {
                const notificationsSnapshot = await database.ref(`notifications/${currentRoom}`).once('value');
                const notifications = notificationsSnapshot.val() || {};
                
                // Store notification for other users to receive
                const notificationPayload = {
                    from: currentUser,
                    message: messageText.substring(0, 100),
                    room: currentRoom,
                    timestamp: Date.now(),
                    type: 'message'
                };
                
                // Send to all users except current user
                Object.entries(notifications).forEach(([userId, subscription]) => {
                    if (userId !== userPresenceId && subscription.username !== currentUser) {
                        // Store notification for this user
                        database.ref(`user_notifications/${userId}/${Date.now()}`).set(notificationPayload);
                        log(`üì¨ Notification queued for ${subscription.username}`);
                    }
                });
                
            } catch (error) {
                log(`Notification sending error: ${error.message}`);
            }
        }

        // GLOBAL CLEANUP FUNCTION - Cleans ALL rooms from Firebase
        async function globalCleanupAllRooms() {
            if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL rooms and chats from Firebase!\n\nThis action cannot be undone. Are you sure?')) {
                return;
            }

            const secondConfirm = confirm('üö® FINAL WARNING: You are about to delete EVERYTHING!\n\nType OK to continue or Cancel to abort.');
            if (!secondConfirm) {
                return;
            }

            log('üö® Starting GLOBAL cleanup of ALL rooms...');
            
            try {
                // Show cleanup progress
                const cleanupStatus = document.createElement('div');
                cleanupStatus.className = 'status info';
                cleanupStatus.innerHTML = `
                    <strong>üßπ Global Cleanup in Progress...</strong><br>
                    <div id="cleanupProgress">Scanning Firebase...</div>
                    <div style="width: 100%; background: #e2e8f0; border-radius: 8px; margin-top: 8px;">
                        <div id="cleanupBar" style="width: 0%; height: 8px; background: #4f46e5; border-radius: 8px; transition: width 0.3s;"></div>
                    </div>
                `;

                if (isJoined) {
                    chatScreen.insertBefore(cleanupStatus, chatScreen.firstChild);
                } else {
                    joinScreen.insertBefore(cleanupStatus, joinScreen.firstChild);
                }

                const progressDiv = document.getElementById('cleanupProgress');
                const progressBar = document.getElementById('cleanupBar');

                // Step 1: Get all rooms
                progressDiv.textContent = 'Step 1/6: Scanning all rooms...';
                progressBar.style.width = '10%';
                
                const roomsSnapshot = await database.ref('rooms').once('value');
                const rooms = roomsSnapshot.val() || {};
                const roomCount = Object.keys(rooms).length;
                
                log(`üìä Found ${roomCount} rooms to delete`);

                // Step 2: Delete all room messages
                progressDiv.textContent = `Step 2/6: Deleting messages from ${roomCount} rooms...`;
                progressBar.style.width = '25%';
                
                const messageDeletions = [];
                Object.keys(rooms).forEach(roomId => {
                    messageDeletions.push(database.ref(`rooms/${roomId}/messages`).remove());
                });
                await Promise.all(messageDeletions);
                
                log(`‚úÖ Deleted messages from ${roomCount} rooms`);

                // Step 3: Delete all room presence data
                progressDiv.textContent = 'Step 3/6: Clearing user presence data...';
                progressBar.style.width = '40%';
                
                const presenceDeletions = [];
                Object.keys(rooms).forEach(roomId => {
                    presenceDeletions.push(database.ref(`rooms/${roomId}/presence`).remove());
                });
                await Promise.all(presenceDeletions);
                
                log(`‚úÖ Cleared presence data from ${roomCount} rooms`);

                // Step 4: Delete all rooms
                progressDiv.textContent = 'Step 4/6: Deleting room structures...';
                progressBar.style.width = '60%';
                
                await database.ref('rooms').remove();
                log('‚úÖ Deleted all room structures');

                // Step 5: Delete all notifications
                progressDiv.textContent = 'Step 5/6: Clearing notification data...';
                progressBar.style.width = '80%';
                
                await database.ref('notifications').remove();
                await database.ref('user_notifications').remove();
                await database.ref('room_notifications').remove();
                log('‚úÖ Cleared all notification data');

                // Step 6: Clean up any remaining data
                progressDiv.textContent = 'Step 6/6: Final cleanup...';
                progressBar.style.width = '100%';

                // Clean up any other potential data structures
                const cleanupRefs = [
                    'room_stats',
                    'user_sessions',
                    'temp_data',
                    'cleanup_logs'
                ];

                const finalCleanup = cleanupRefs.map(ref => 
                    database.ref(ref).remove().catch(() => {}) // Ignore errors for non-existent refs
                );
                await Promise.all(finalCleanup);

                // Success message
                setTimeout(() => {
                    cleanupStatus.className = 'status success';
                    cleanupStatus.innerHTML = `
                        <strong>üéâ Global Cleanup Complete!</strong><br>
                        Successfully deleted:<br>
                        ‚Ä¢ ${roomCount} rooms<br>
                        ‚Ä¢ All messages and chat history<br>
                        ‚Ä¢ All user presence data<br>
                        ‚Ä¢ All notification subscriptions<br>
                        ‚Ä¢ All temporary data<br>
                        <button onclick="this.parentElement.remove()" style="margin-top: 0.5rem;">‚úÖ Close</button>
                    `;
                    
                    log(`üéâ GLOBAL CLEANUP COMPLETE: Removed ${roomCount} rooms and all associated data`);
                }, 1000);

            } catch (error) {
                log(`üö® Global cleanup error: ${error.message}`);
                
                // Error message
                document.querySelector('.status').className = 'status error';
                document.querySelector('.status').innerHTML = `
                    <strong>‚ùå Cleanup Failed</strong><br>
                    Error: ${error.message}<br>
                    Some data may still remain in Firebase.<br>
                    <button onclick="this.parentElement.remove()" style="margin-top: 0.5rem;">Close</button>
                `;
            }
        }

        // Enhanced cleanup with room-specific and global options
        async function cleanupRoom() {
            if (!currentRoom) {
                // If not in a room, offer global cleanup
                if (confirm('No active room. Would you like to perform GLOBAL cleanup of ALL rooms?')) {
                    await globalCleanupAllRooms();
                }
                return;
            }
            
            log('Starting room cleanup...');
            
            try {
                const snapshot = await messagesRef.once('value');
                const messages = snapshot.val() || {};
                const now = Date.now();
                const deletions = [];

                // Get current room presence to avoid deleting active users' messages
                const presenceSnapshot = await database.ref(`rooms/${currentRoom}/presence`).once('value');
                const presence = presenceSnapshot.val() || {};
                const activeUserIds = Object.keys(presence).filter(id => presence[id].online);

                Object.keys(messages).forEach(key => {
                    const message = messages[key];
                    const age = now - message.timestamp;
                    
                    // Delete vanish mode messages older than 24h OR from users who left
                    if (message.mode === 'vanish') {
                        const shouldDelete = age > 24 * 60 * 60 * 1000 || 
                                           (message.userId && !activeUserIds.includes(message.userId));
                        if (shouldDelete) {
                            deletions.push(messagesRef.child(key).remove());
                        }
                    }
                    // Delete storage mode messages older than 7 days
                    else if (message.mode === 'storage' && age > 7 * 24 * 60 * 60 * 1000) {
                        deletions.push(messagesRef.child(key).remove());
                    }
                });

                await Promise.all(deletions);
                log(`Cleanup complete: ${deletions.length} messages removed from ${currentRoom}`);

                // Check if room is completely empty and should be deleted
                const remainingMessages = await messagesRef.once('value');
                const remainingPresence = await database.ref(`rooms/${currentRoom}/presence`).once('value');
                
                if (!remainingMessages.exists() && !remainingPresence.exists()) {
                    await database.ref(`rooms/${currentRoom}`).remove();
                    log('üóëÔ∏è Empty room completely removed');
                }
                
            } catch (error) {
                log(`Cleanup error: ${error.message}`);
            }
        }

        // Join room with enhanced presence and notifications
        async function joinRoom() {
            const username = usernameInput.value.trim();
            const roomCode = roomCodeInput.value.trim();
            const passphrase = passphraseInput.value.trim();
            const mode = chatModeSelect.value;

            if (!username || !roomCode || !passphrase) {
                log('Please fill all fields');
                return;
            }

            currentUser = username;
            currentRoom = roomCode;
            currentPassphrase = passphrase;
            currentMode = mode;
            
            log(`Joining room ${roomCode} as ${username} in ${mode} mode...`);
            
            // Setup Firebase references
            messagesRef = database.ref(`rooms/${roomCode}/messages`);
            roomRef = database.ref(`rooms/${roomCode}`);
            connectionRef = database.ref('.info/connected');
            
            // Setup user presence
            await setupPresence();
            
            // Request notification permission
            await requestNotificationPermission();
            
            // Listen for user notifications (push notification simulation)
            const userNotificationsRef = database.ref(`user_notifications/${userPresenceId}`);
            userNotificationsRef.on('child_added', (snapshot) => {
                const notification = snapshot.val();
                if (notification && notification.from !== currentUser) {
                    // Show local notification if app is backgrounded
                    if (document.hidden && notificationPermission === 'granted') {
                        showLocalNotification(notification.from, notification.message);
                    }
                    
                    // Clean up notification after showing
                    setTimeout(() => {
                        snapshot.ref.remove();
                    }, 5000);
                }
            });

            // Listen for messages
            messagesRef.on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (!message) return;

                const decryptedText = decrypt(message.text, currentPassphrase);
                if (decryptedText) {
                    const isOwn = message.username === currentUser && message.userId === userPresenceId;
                    addMessage(message.username, decryptedText, message.timestamp, isOwn, message.id);
                    
                    // Show notification for messages from others (if app is in background)
                    if (!isOwn && document.hidden && notificationPermission === 'granted') {
                        showLocalNotification(message.username, decryptedText);
                    }
                } else {
                    log('Failed to decrypt message (wrong passphrase?)');
                }
            });

            // Listen for messages being removed
            messagesRef.on('child_removed', (snapshot) => {
                const messageId = snapshot.key;
                const messageElement = document.getElementById(`msg-${messageId}`);
                if (messageElement) {
                    messageElement.style.opacity = '0';
                    setTimeout(() => messageElement.remove(), 300);
                }
            });

            // Monitor connection status
            updateConnectionStatus();

            // Update UI
            roomDisplay.textContent = `Room: ${roomCode}`;
            userDisplay.textContent = `User: ${username}`;
            modeDisplay.innerHTML = `<div class="mode-badge ${mode}-mode">${mode.toUpperCase()}</div>`;
            
            // Save data and switch screens
            saveUserData();
            isJoined = true;
            joinScreen.style.display = 'none';
            chatScreen.style.display = 'flex';
            
            messageInput.focus();
            log('Successfully joined room');
            
            // Auto-cleanup on join
            setTimeout(cleanupRoom, 1000);
        }

        // Show local notification
        function showLocalNotification(username, message) {
            if ('Notification' in window && notificationPermission === 'granted') {
                const notification = new Notification(`${username} in ${currentRoom}`, {
                    body: message.substring(0, 100) + (message.length > 100 ? '...' : ''),
                    icon: '/icon-192.png',
                    badge: '/badge-72.png',
                    tag: `jayara-${currentRoom}`,
                    requireInteraction: false,
                    silent: false
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };

                // Auto-close after 5 seconds
                setTimeout(() => notification.close(), 5000);
            }
        }

        // Leave room with proper cleanup
        async function leaveRoom() {
            log('Leaving room...');
            
            try {
                // Mark user as offline and set leave time
                if (presenceRef) {
                    await presenceRef.update({ 
                        online: false, 
                        leftAt: Date.now() 
                    });
                    
                    // For vanish mode, clean up user's messages immediately
                    if (currentMode === 'vanish') {
                        await cleanupUserMessages(userPresenceId);
                    }
                    
                    // Remove presence after a delay (for graceful disconnect)
                    setTimeout(async () => {
                        try {
                            await presenceRef.remove();
                            await database.ref(`notifications/${currentRoom}/${userPresenceId}`).remove();
                        } catch (e) {
                            // Ignore errors on cleanup
                        }
                    }, 1000);
                }
                
                // Clean up Firebase listeners
                if (messagesRef) {
                    messagesRef.off();
                    messagesRef = null;
                }
                
                if (roomRef) {
                    roomRef.off();
                    roomRef = null;
                }
                
                presenceRef = null;
                
            } catch (error) {
                log(`Error during cleanup: ${error.message}`);
            }
            
            // Clear state based on mode
            if (currentMode === 'vanish') {
                // Vanish mode: clear everything
                localStorage.removeItem('jayara_active_session');
                localStorage.removeItem('jayara_mode');
                currentUser = '';
                currentRoom = '';
                passphraseInput.value = '';
            } else {
                // Storage mode: keep session info but clear passphrase
                passphraseInput.value = '';
            }
            
            currentPassphrase = '';
            isJoined = false;
            userPresenceId = '';
            
            // Clear UI
            messagesDiv.innerHTML = '';
            chatDebugLog.innerHTML = '<div class="debug-entry">Left room successfully</div>';
            
            joinScreen.style.display = 'flex';
            chatScreen.style.display = 'none';
            
            log('Left room and cleaned up data');
            
            // Trigger room cleanup check
            setTimeout(checkRoomCleanup, 2000);
        }

        // Clear local messages
        function clearLocal() {
            messagesDiv.innerHTML = '';
            log('Local messages cleared');
        }

        // Event listeners
        document.getElementById('joinButton').addEventListener('click', joinRoom);
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('leaveButton').addEventListener('click', leaveRoom);
        // Event listeners
        document.getElementById('joinButton').addEventListener('click', joinRoom);
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('leaveButton').addEventListener('click', leaveRoom);
        document.getElementById('clearLocalButton').addEventListener('click', clearLocal);
        document.getElementById('cleanupButton').addEventListener('click', cleanupRoom);
        document.getElementById('cleanupRoomButton').addEventListener('click', cleanupRoom);
        document.getElementById('globalCleanupButton').addEventListener('click', globalCleanupAllRooms);
        document.getElementById('globalCleanupChatButton').addEventListener('click', globalCleanupAllRooms);

        // Notification permission button
        document.getElementById('requestNotificationsButton').addEventListener('click', requestNotificationPermission);

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Check notification permission on load
        function checkNotificationPermission() {
            if ('Notification' in window) {
                notificationPermission = Notification.permission;
                const notifButton = document.getElementById('requestNotificationsButton');
                
                if (notificationPermission === 'default') {
                    notifButton.style.display = 'inline-block';
                    notifButton.textContent = 'üîî Enable Notifications';
                } else if (notificationPermission === 'denied') {
                    notifButton.style.display = 'inline-block';
                    notifButton.textContent = 'üîï Notifications Blocked';
                    notifButton.disabled = true;
                } else {
                    notifButton.style.display = 'none';
                }
            }
        }

        // Enhanced message handling with better encryption
        function addMessage(username, text, timestamp, isOwn = false, messageId) {
            // Check for duplicate messages
            if (document.getElementById(`msg-${messageId}`)) {
                return;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'sent' : 'received'}`;
            messageDiv.id = `msg-${messageId}`;
            
            // Add message content
            const messageText = document.createElement('div');
            messageText.className = 'message-text';
            messageText.textContent = text;
            
            const messageMeta = document.createElement('div');
            messageMeta.className = 'message-meta';
            messageMeta.textContent = `${username} ‚Ä¢ ${new Date(timestamp).toLocaleTimeString()}`;
            
            messageDiv.appendChild(messageText);
            messageDiv.appendChild(messageMeta);
            
            messagesDiv.appendChild(messageDiv);

            // Auto-scroll with smooth behavior
            setTimeout(() => {
                messagesDiv.scrollTo({
                    top: messagesDiv.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);

            // Add unread indicator if app is hidden
            if (document.hidden && !isOwn) {
                messageDiv.classList.add('unread');
                updateUnreadCount();
            }
        }

        // Unread message management
        let unreadCount = 0;

        function updateUnreadCount() {
            unreadCount++;
            document.title = `(${unreadCount}) Jayara - ${currentRoom}`;
        }

        function clearUnreadCount() {
            unreadCount = 0;
            document.title = `Jayara - ${currentRoom}`;
            
            // Remove unread indicators
            document.querySelectorAll('.message.unread').forEach(msg => {
                msg.classList.remove('unread');
            });
        }

        // Clear unread when app becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && isJoined) {
                clearUnreadCount();
            }
        });

        // Advanced room statistics
        async function getRoomStats() {
            if (!currentRoom) return;

            try {
                const [messagesSnap, presenceSnap] = await Promise.all([
                    messagesRef.once('value'),
                    database.ref(`rooms/${currentRoom}/presence`).once('value')
                ]);

                const messages = messagesSnap.val() || {};
                const presence = presenceSnap.val() || {};
                
                const messageCount = Object.keys(messages).length;
                const onlineUsers = Object.values(presence).filter(u => u.online).length;
                const totalUsers = Object.keys(presence).length;

                log(`üìä Room stats: ${messageCount} messages, ${onlineUsers}/${totalUsers} users online`);
                
                return { messageCount, onlineUsers, totalUsers };
            } catch (error) {
                log(`Stats error: ${error.message}`);
                return null;
            }
        }

        // Show room stats periodically
        setInterval(() => {
            if (isJoined) {
                getRoomStats();
            }
        }, 5 * 60 * 1000); // Every 5 minutes

        // Enhanced error handling and recovery
        function handleFirebaseError(error) {
            log(`üö® Firebase Error: ${error.message}`);
            
            if (error.code === 'PERMISSION_DENIED') {
                log('‚ùå Permission denied - check Firebase rules');
            } else if (error.code === 'NETWORK_ERROR') {
                log('üì° Network error - will retry when online');
            } else {
                log('üîÑ Attempting to reconnect...');
                
                // Try to rejoin after a delay
                setTimeout(() => {
                    if (!isJoined && currentUser && currentRoom && currentPassphrase) {
                        log('üîÑ Auto-reconnecting...');
                        joinRoom();
                    }
                }, 5000);
            }
        }

        // Enhanced connection monitoring with retry logic
        let connectionRetries = 0;
        const maxRetries = 3;

        function updateConnectionStatus() {
            if (isJoined && connectionRef) {
                connectionRef.on('value', (snapshot) => {
                    const connected = snapshot.val();
                    if (connected) {
                        log('‚úÖ Connected to Firebase');
                        connectionRetries = 0;
                    } else {
                        log('‚ùå Disconnected from Firebase');
                        
                        // Implement exponential backoff retry
                        if (connectionRetries < maxRetries) {
                            const delay = Math.pow(2, connectionRetries) * 1000;
                            setTimeout(() => {
                                connectionRetries++;
                                log(`üîÑ Retry attempt ${connectionRetries}/${maxRetries}`);
                            }, delay);
                        }
                    }
                });
            }
        }

        // Message delivery confirmation (optional enhancement)
        async function confirmMessageDelivery(messageId) {
            try {
                await database.ref(`rooms/${currentRoom}/delivery/${messageId}`).set({
                    userId: userPresenceId,
                    deliveredAt: Date.now()
                });
            } catch (error) {
                // Ignore delivery confirmation errors
            }
        }

        // Initialize app with all enhancements
        function initializeApp() {
            loadSavedData();
            checkNotificationPermission();
            log('üöÄ Jayara initialized with enhanced features');
            
            // Show feature hints
            if ('Notification' in window && 'serviceWorker' in navigator) {
                log('üí° Tip: Enable notifications to receive messages when app is closed');
            }
            
            if ('BeforeInstallPromptEvent' in window) {
                log('üì± Tip: This app can be installed as a PWA for better experience');
            }
        }

        // PWA installation prompt handling
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button or hint
            log('üì± PWA installation available');
            
            const installHint = document.createElement('div');
            installHint.className = 'status info';
            installHint.innerHTML = `
                <strong>Install Jayara</strong><br>
                Install this app for better performance and offline access<br>
                <button onclick="installPWA()" style="margin-top: 0.5rem;">üì± Install App</button>
                <button onclick="dismissInstall()" class="btn-secondary" style="margin-top: 0.5rem; margin-left: 0.5rem;">Maybe Later</button>
            `;
            
            if (!isJoined) {
                joinScreen.insertBefore(installHint, joinScreen.firstChild);
            }
        });

        // PWA installation functions
        window.installPWA = async function() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    log('üì± PWA installed successfully');
                } else {
                    log('üì± PWA installation declined');
                }
                
                deferredPrompt = null;
                document.querySelector('.status')?.remove();
            }
        };

        window.dismissInstall = function() {
            document.querySelector('.status')?.remove();
            deferredPrompt = null;
        };
        document.getElementById('clearLocalButton').addEventListener('click', clearLocal);
        document.getElementById('cleanupButton').addEventListener('click', cleanupRoom);
        document.getElementById('cleanupRoomButton').addEventListener('click', cleanupRoom);

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Handle page visibility for notifications and presence
        document.addEventListener('visibilitychange', () => {
            if (isJoined && presenceRef) {
                if (document.hidden) {
                    log('üì± App backgrounded - enabling notifications');
                } else {
                    log('üëÅÔ∏è App focused - disabling notifications');
                }
            }
        });

        // Handle page unload for cleanup
        window.addEventListener('beforeunload', () => {
            if (isJoined && presenceRef && currentMode === 'vanish') {
                // For vanish mode, immediately mark as offline
                presenceRef.update({ online: false, leftAt: Date.now() });
            }
        });

        // Auto-cleanup interval (every 5 minutes for better real-time cleanup)
        setInterval(() => {
            if (isJoined) {
                cleanupRoom();
            }
        }, 5 * 60 * 1000);

        // Connection status monitoring
        let isOnline = navigator.onLine;
        let connectionRef = null;

        function updateConnectionStatus() {
            if (isJoined && connectionRef) {
                connectionRef.on('value', (snapshot) => {
                    const connected = snapshot.val();
                    if (connected) {
                        log('‚úÖ Connected to Firebase');
                    } else {
                        log('‚ùå Disconnected from Firebase');
                    }
                });
            }
        }

        window.addEventListener('online', () => {
            isOnline = true;
            log('üì∂ Back online');
            updateConnectionStatus();
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            log('üìµ Offline mode');
        });

        // Initialize app
        initializeApp();

        // Register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        log('SW registered successfully');
                    })
                    .catch((error) => {
                        log('SW registration failed');
                    });
            });
        }
    </script>

    <!-- Manifest and SW scripts need to be separate files -->
    <script>
        // Create manifest.json dynamically
        const manifest = {
            "name": "Jayara - Secure Chat",
            "short_name": "Jayara",
            "description": "End-to-end encrypted chat application",
            "start_url": "/",
            "display": "standalone",
            "background_color": "#ffffff",
            "theme_color": "#4f46e5",
            "icons": [
                {
                    "src": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiByeD0iMjQiIGZpbGw9IiM0ZjQ2ZTUiLz4KPHN2ZyB4PSI0OCIgeT0iNDgiIHdpZHRoPSI5NiIgaGVpZ2h0PSI5NiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0yMCA0SDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWNmMwLTEuMS0uOS0yLTItMnpNMjAgMTZINHYtNmgxNnY2eiIvPgo8L3N2Zz4KPC9zdmc+",
                    "sizes": "192x192",
                    "type": "image/svg+xml"
                }
            ]
        };

        // Create a blob URL for the manifest
        const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('link[rel="manifest"]').href = manifestURL;
    </script>
</body>
</html>